#!/usr/bin/env python3

######################################################
# Slippy Assignment
######################################################

import sys
import re
from args_parser import ArgsParser
from sed_parser import SedParser

######################################################
# Parse arguments
######################################################

args_parser = ArgsParser(sys.argv[1:])
commands = SedParser(args_parser.get_sed_command()).get_commands()

######################################################
# Helpers
######################################################

def print_input(line):
    # Print input if required
    if (args_parser.should_print_input_lines()):
        print(line, end='')

# Given a line of string (line) and affix object ({value, is_regex}), 
# check if it matches the given number or regex (value)
# Returns whether the program should continue to run or not
def is_line_and_value_matching(line, affix_object, count, is_end):
    if affix_object["is_range"] and not range:
        # First element of range not found
        pass
    elif affix_object["is_range"] and range:
        # Currently in range
        pass
    else:
        # Not a range prefix
        value, is_regex = affix_object["start"].values()
        if (is_regex and re.search(value, line)) or (count == value) or (value == '$' and is_end):
            return True
        return False

def handle_command(commands, line, count, is_end):
    running = True
    for command in commands:
        if command['command'] == 'p':
            running = p(command, line, count, is_end)
        elif command['command'] == 'q':
            running = q(command, line, count, is_end)
        elif command['command'] == 'd':
            running = d(command, line, count, is_end)
        elif command['command'] == 's':
            running = s(command, line, count, is_end)
        elif command['command'] == '':
            print_input(line)
    return running

######################################################
# Cases
######################################################

# Handle q case. Return a boolean to indicate termination or continuation
def q(command, line, count, is_end):
    print_input(line)
    return not is_line_and_value_matching(line, command['prefix'], count, is_end)

# Handle p case. Return a boolean to indicate termination or 
def p(command, line, count, is_end):
    print_input(line)
    if is_line_and_value_matching(line, command['prefix'], count, is_end):
        print(line, end='')
    return True

def d(command, line, count, is_end):
    if not is_line_and_value_matching(line, command['prefix'], count, is_end):
        print_input(line)  
    return True

def s(command, line, count, is_end):
    if is_line_and_value_matching(line, command['prefix'], count, is_end):
        src, dest = command['postfix']['affix']
        if dest and dest[-1] == 'g':
            print_input(re.sub(src, dest[:-1], line))    
        else:
            print_input(re.sub(src, dest, line, count=1))
    else:
        print_input(line) 
    return True

######################################################
# Main
######################################################

count = 1
running = True
buffer = [[args_parser.get_next_line(), False]]
range = False

while True:

    if not buffer:
        break

    # Populate buffer with next line
    next_line = args_parser.get_next_line()
    if not next_line:
        buffer[-1][-1] = True
    else:
        buffer.append([next_line, False])

    current_line, is_end = buffer.pop(0)
    running = handle_command(commands, current_line, count, is_end)
    count += 1

    if not running: 
        break
