#!/usr/bin/env python3

######################################################
# Slippy Assignment
######################################################

import sys
import re
from args_parser import ArgsParser
from sed_parser import SedParser

######################################################
# Parse arguments
######################################################

args_parser = ArgsParser(sys.argv[1:])
commands = SedParser(args_parser.get_sed_command()).get_commands()

######################################################
# Helpers
######################################################

def throw_error():
    print("slippy: command line: invalid command", file=sys.stderr)
    sys.exit(1)

# Given a line of string (line) and affix object ({value, is_regex}), 
def is_line_and_value_matching(line, affix_object, count, is_end):
    value, is_regex = affix_object.values()
    if (is_regex and re.search(value, line)) or (count == value) or (value == '$' and is_end):
        return True
    return False

def update_range_status():  
    pass
    # if affix_object["is_range"] and range is False:
    #     # First element of range is finally found
    #     if determine_to_continue(affix_object["start"]):
    #         range = True
    #     return True
    # elif affix_object["is_range"] and range is True:
    #     # Currently in range
    #     if determine_to_continue(affix_object["end"]):
    #         range = "pending"
    #         return True
    #     return False
    # else:
    #     # Not a range prefix
    #     return determine_to_continue(affix_object["start"])

def handle_command(commands, line, count, is_end):
    global output, running
    for command in commands:
        if command['command'] == 'p':
            p(command, line, count, is_end)
        elif command['command'] == 'q':
            q(command, line, count, is_end)
        elif command['command'] == 'd':
            d(command, line, count, is_end)
        elif command['command'] == 's':
            s(command, line, count, is_end)
        elif command['command'] == '':
            pass
    for i in output:
        print(i, end='')
    output = []

######################################################
# Cases
######################################################

# Handle q case. Return a boolean to indicate termination or continuation
def q(command, line, count, is_end):
    global running
    # Range prefix is not allowed with q command
    if command["prefix"]["is_range"]:
        throw_error()
    running = not is_line_and_value_matching(line, command['prefix'], count, is_end)

# Handle p case. Return a boolean to indicate termination or 
def p(command, line, count, is_end):
    global range, output
    # Range Case 
    if command['prefix']["is_range"]:
        # Update range status
        if range is False and is_line_and_value_matching(line, command['prefix']['start'], count, is_end):
            range = True
            output.append(line)
        elif range is True and is_line_and_value_matching(line, command['prefix']['end'], count, is_end):
            range = None # None means range has passed
            output.append(line)
        elif range is True:
            output.append(line)
    # Non-range Case
    else:
        if is_line_and_value_matching(line, command['prefix']['start'], count, is_end):
            output.append(line)

def d(command, line, count, is_end):
    global range, output
    cont = is_line_and_value_matching(line, command['prefix'], count, is_end)
    if len(output) > 0:
        if command['prefix']["is_range"]:
            # If within range, pop it
            if range and cont:
                output.pop()
        else:
            if cont:
                output.pop()

def s(command, line, count, is_end):
    global range, output
    if is_line_and_value_matching(line, command['prefix'], count, is_end) or range:
        src, dest = command['postfix']['affix']
        if len(output) > 0:
            if dest and dest[-1] == 'g':
                prev = output.pop()
                output.append(re.sub(src, dest[:-1], prev))
            else:
                prev = output.pop()
                output.append(re.sub(src, dest, prev, count=1))
        if range == "pending":
            range = None

######################################################
# Main
######################################################

count = 1
running = True
buffer = [[args_parser.get_next_line(), False]]
range = False
output = []

while True:

    if not buffer:
        break

    # Populate buffer with next line
    next_line = args_parser.get_next_line()
    if not next_line:
        buffer[-1][-1] = True
    else:
        buffer.append([next_line, False])

    current_line, is_end = buffer.pop(0)
    if args_parser.should_print_input_lines():
        output.append(current_line)
    handle_command(commands, current_line, count, is_end)
    count += 1

    if not running: 
        break
